---
title: "Pulling ACS Data for Inspace Projects"
author: "Amy Youngbloom"
date: "3/31/2022"
output: html_document
---

```{r setup, include=FALSE}
#knit this file with the working directory of "workspace/" instead of "workspace/examples"
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, eval=FALSE)
knitr::opts_knit$set(root.dir = '/home/rstudio/workspace/')
```

```{r load packages & ACMT}
library(tidycensus)
library(tidyverse)
library(dplyr)
#install.packages('janitor')
library(janitor)
library(reshape2)
setwd("/home/rstudio/workspace/")
source("GeocoderACMT.R")
```


### Introduction

To allow for pooling of Inspace projects, we have generated a wishlist of ACS variables that we are hoping each project can pull for all participants. ACS variables will be pulled for 2017 (2013-2017 5-year ACS) as well as for the 5-year period centered around your initial year of enrollment. For example, if enrollment in your program began in 2016, you would want to pull data from the 2014-2019 ACS (year=2019). 

This document lays out instructions for how to pull the requested ACS variables for each participant. 

Before we get started, we will pull in the geocodeded dataset: 

```{r import geocoded data}
setwd("/home/rstudio/workspace/Inspace")
dataset_geocode<-read.csv('dataset_geocoded.csv')

```

Your dataset should be formatted as follows, with the following column names: 

| id  |  lat      | long        | 
|-----|-----------|-------------|
| 01  | 47.568922 | -122.306422 |
| 02  | 47.632264 | -122.314978 |
| 03  | 47.634820 | -122.292769 |
| ..  | ......... | ........... |


### 1 Designate ACS variables to be pulled

* The first step in pulling a list of ACS variables is to desigate the list of variables to be pulled. There is a built in list of ACS variables (ACSColumns.csv) that is downloaded with the GecoderACMT.R code. The interpolation strategy (to sum or not) for that built in list of ACS variables is written out in the GeocoderACMT.R code as well. We can modify this list of variables and the interpolation lists for the variables that we are interested in. Make sure the list of Inspace ACS variables to pull is uploaded into your workspace/Inspace folder, then proceed as follows.

* Create a list of the variables of interest. *

```{r set acs vars}

setwd("/home/rstudio/workspace/Inspace")
acs_columns_inspace<-read.csv('ACSColumns_inspace.csv')

#overwrite current ACSColumns.csv file
setwd("/home/rstudio/workspace/ACMT")
write.csv(acs_columns_inspace, 'ACSColumns.csv')

```

* If you are using a year prior to 2015, check with the InSpace team so that they can verify that those same variable columns codes apply to the same variables for that year. 

### 2 Designate settings (radius, year, count names, proportion names) for ACS variable pull

  Next, we will create count and proportion names from the list of ACS variables that we just created, and designate those named count and proportion variables for our 'names_of_variables_to_get' vector. We also need to designate the codes_of_acs_variables_to_get vector from our ACS variable dataframe and interpolation strategy. In addition, we can desigate the radius (or radii) and year for pulling variables. 

```{r designate names and settings}
##create 'count' versions of each variable name and 'proportion' versions for each #ACS variable where applicable
acs_count_names<-paste(acs_columns_inspace$var_name, "count", sep="_")
if (length(acs_columns_inspace$var_name[acs_columns_inspace$universe_col != ""]) == 0) {   # prevent having something that is exactly "_proportion"
  acs_proportion_names <- character(0)
} else {
  acs_proportion_names <- paste(acs_columns_inspace$var_name[acs_columns_inspace$universe_col !=''], "proportion", sep="_")   # only non-universal variables have proportions
}

#Designate interpolation strategy for variables
acs_variable_name_to_interpolate_by_sum_boolean_mapping<-acs_columns_inspace$interpolation
names(acs_variable_name_to_interpolate_by_sum_boolean_mapping)<-acs_columns_inspace$acs_col

#Set the list of variable codes, the list of variable names, the radius, and the year for the data you want pulled
codes_of_acs_variables_to_get<-acs_columns_inspace$acs_col
names_of_variables_to_get<-c(acs_count_names, acs_proportion_names)
radius_vector <- c(500, 1000, 5000)#set the radius for the area of interest
years <- c(2017, 2018) #set the year(s) for the data of interest

```


### 3 Create additional columns in the dataset for each variable to be pulled

  In order to directly add the measures to your dataset, we first need to create a column for each variable at each level (each year, each radius). 
  

```{r variable columns}

dataset_acs<-dataset_geocode

#create dataset with a column for each variable at each radius level
var.cols<-data.frame(matrix(nrow=nrow(dataset_acs), ncol=(length(names_of_variables_to_get)))) #create dataset of columns
colnames(var.cols)<-names_of_variables_to_get #name the columns

dataset_acs<-cbind(var.cols, dataset_acs)

```

## 4. Run the ACMT Loop to pull ACS data and interpolate each measures for each lat/long

```{r acmt loop, warnings='hide', results='hide'}
setwd("/home/rstudio/workspace")

#run loop to pull variables
for(year in years){
  year<-year
  print(year)
for(radius in 1:length(radius_vector)){
  #radius<-1 #for testing
radius<-radius_vector[radius]
dataset_radius<-dataset_acs
print(radius)

for(id in 1:nrow(dataset_radius)) {
   tryCatch({if(!is.na(dataset_radius[,1][id])) next #skip the row if the data is already there
  if(!is.na(dataset_radius[,1][id])) next #skip the row if the data is already there
  print(id) #print the number to keep track of progress
  latitude<-dataset_radius$lat[id] #set lat
  longitude<-dataset_radius$long[id] #set long
  
  environmental_measures<-get_acmt_standard_array(long=longitude, lat=latitude, radius_meters = radius, year=year, codes_of_acs_variables_to_get = codes_of_acs_variables_to_get[57:58]) #pull measures for given lat & long
 
      for(name_of_variable in names_of_variables_to_get){ #for each measures, get the value and put it into the column of the same name
     value_of_variable <- environmental_measures[environmental_measures$names == name_of_variable,]$values  
     dataset_radius[[name_of_variable]][id]<-value_of_variable
  }

 for (name_of_variable in names_of_variables_to_get) {
        dataset_radius[[name_of_variable]][id] <- environmental_measures[environmental_measures$names == name_of_variable, ]$values  
 }},error=function(e){cat("ERROR :", conditionMessage(e), "\n")}) #this will print any error messages
}

if(radius==500) {
dataset_acs2<-dataset_radius
dataset_acs2$radius<-500}

if(radius>500){
dataset_radius$radius<-radius
dataset_acs2<-rbind(dataset_acs2, dataset_radius)
}
}
#clean up dataset & set name:  
dataset_acs2<-dataset_acs2 %>% 
  mutate(year=year) %>%
  dplyr::select(id, radius, year, everything(), -lat, -long)

if(year==2017){
 dataset_acs2017<- dataset_acs2 #create a dataset for each year
}
if(year!=2017){
  dataset_acsyear<-dataset_acs2
}
}

dataset_acs_full<-rbind(dataset_acs2017, dataset_acsyear) #combine acs 2018 data with year of program enrollment
```

## 5 Next, pull the county GEOID for each lat/long location

```{r pull county GEOIDs}
##transform dataset1 lat/long into sf file with geometry: 
latlong_sf <- st_as_sf(dataset_acs, coords = c("long", "lat"), crs = 4326)
# find intersecting counties of lat/long points:
intersected<-st_intersects(latlong_sf, counties)
latlong_final <- latlong_sf %>%
  mutate(intersection = as.integer(intersected),
         county_GEOID = if_else(is.na(intersection), "",
                        as.character(counties$GEOID[intersection]))) %>%
  dply::select(id, county_GEOID)

dataset_acs_full<-merge(dataset_acs_full, latlong_final)

```

## 6 finally export your dataset_acs2018 & other years you pulled data from: 

```{r export}
setwd("/home/rstudio/workspace/Inspace")
write.csv(datsaet_acs_full, 'dataset_acs_full.csv')

```
